### 멀티스레딩과 동시성

- CPU 의 동시적 작업 처리는, CPU 코어 개수보다 스레드의 개수가 많을 때 (즉, CPU core < Thread) 발생한다.
- 같은 프로그램 안에서 실행되는 여러 스레드가 읽기 및 쓰기 작업을 같은 메모리 영역에서 동시에 실행할 경우 동시성 문제가 대두된다.
- 동시성 문제라 함은, 하나의 스레드가 어떤 메모리 영역의 데이터를 쓰고 있는데 또 다른 스레드가 같은 메모리 영역의 데이터를 읽거나 쓸 경우 발생할 수 있는 문제다.

**동기화란?**

프로세스 혹은 스레드 간 공유 영역에 대한 동시 접근으로 인해 발생하는 데이터 불일치를 막고, 데이터의 일관성을 유지하기 위해 순**차적으로 공유 영역을 수행하도록 보장하는 메카니즘이라 할 수 있다.**

**critical section (=임계영역)**

임계 영역이란 둘 이상의 스레드가 동시에 접근해서는 안되는 공유자원에 접근하는 `코드 영역`을 말한다.

**임계 영역에 대한 문제를 해결하는 방법 3가지 (모두 만족해야 함)**

1. 상호 배제 (Mutual Exclustion)
    - 어떤 스레드가 임계영역에서 실행중이라면 다른 스레드는 동일한 임계영역을 실행할 수 없다.
2. Progress (진행)
    - 임계 구역에서 실행 중인 스레드가 없고, 임계 구역에 진입하려는 스레드가 있을 때 어떤 스레드가 들어갈 것인지 적절히 선택해 주어야 하고, 무한정 미뤄져서는 안된다.
3. Bounded Waiting (한정 대기)
    - 다른 스레드가 임계 영역에 들어가도록 요청한 후, 해당 요청이 수락되기 전에 기존 스레드가 임계 영역에서 실행할 수 있는 횟수에 제한이 있어야 한다.
    → 즉, 임계영역에서 너무 긴 시간을 보내는 스레드 때문에 다른 스레드가 무한정 대기하는 현상이 발생할 수 있는데, 이것을 방지하라는 의미이다. (=기아상태가 발생하지 않도록 한다.)

**Race condition (경쟁상태)**

- 여러 스레드가 동시에 공유 자원에 액세스하고 조작할 때 스레드 간 엑세스하는 순서나 시점에 따라 실행결과가 달라질 수 있는데, 이것을 경쟁 상태라 한다.
- 경쟁상태는 임계영역 문제가 해결되지 않은 상태에서 여러 스레드가 동시에 임계영역에 접근해서 공유 데이터를 조작함으로써 발생하는 상태라 할 수 있다.

**Thread Safe 조건**

- **스레드의 스택에 한정해서 상태를 관리**
    - 메소드 내에서 생성한 객체 (new 키워드) 는 heap 영역에 저장되는데, 아래와 같이 각 스레드 마다 heap 영역에 생성되며, 각 스레드는 서로 다른 객체를 참조하고 있기 때문에 thread safe 하다.
        
        <img width="619" alt="스크린샷 2024-05-09 오후 11 30 57" src="https://github.com/kihyuk-jeong/Java-Concurrency/assets/39195377/9f1362a6-b7fb-4370-9203-52cb40f7afc2">

        
    - 단, 파라미터로 객체를 받는다면 모든 스레드가 동일한 파라미터 객체를 참조하고 있기 때문에 thread safe 하지 않다.
    - 정리하자면, new 키워드로 생성한 객체는 각 스레드마다 독립적인 heap 메모리 영역을 참조하기 때문에 스레드에 안전하지만, 외부에서 들어온 파라미터 객체의 경우 동일한 heap 메모리 영역을 참조하고 있기 때문에 스레드에 안전하지 않다.
- ThreadLocal 사용
- 불변 객체 사용
- 임계영역 동기화
- 동기화 도구 사용

---

### 동기화 기법

**상호 배제 (=뮤텍스 / 오로지 하나의 락만 관리)
→ 요약하자면, lock (flag) 를 통한 동시성 제어**

- 뮤텍스 (Mutual Exclusion) 또는 상호 배제는 공유 자원에 대한 경쟁 상태를 방지하고 동시성 제어를 위한 락 메커니즘이다.
- 스레드가 임계영역에서 뮤텍스 객체의 플래그를 소유하고 있으면, 다른 스레드가 액세스할 수 없고, 이 때 해당 임계 영역에 액세스를 시도하는 스레드는 모두 차단되고, 뮤텍스 객체 플래그가 해제된 경우에만 액세스할 수 있다.
    - 즉, 이 메커니즘은 뮤텍스 락을 가진 오직 한개의 스레드만이 임계영역에 진입할 수 있으며, 락을 흭득한 스레드만이 락을 해제 할 수 있다.

**뮤텍스의 문제점**

- 데드락 : 서로 다른 스레드가 서로가 가진 락을 기다리는 현상 발생
- 우선 순위 역전 : 우선순위가 높은 스레드가 락을 흭득하지 못해 우선순위가 낮은 스레드보다 늦게 처리될 수 있음
- 오버헤드 / 성능저하 : 락 흭득을 위해 스레드 대기 및 스레드 스케쥴링 등 스레드의 실행 시간 블록

**세마포어 (여러 개의 락을 생성 가능)**

**→ 요약하자면, 공유 자원에 대한 접근을 제어하기 위한 신호전달 메커니즘 동기화**

- S (변수/Lock 갯수) , P (함수/락 흭득 및 S—), V(함수/락 반납 및 S++)
- 설정한 S 만큼 락 흭득이 가능하며, 즉 S 만큼 공유자원(임계영역)에 접근이 가능하다.
- 뮤텍스보다 비교적 유연한 동기화 기법
- P 함수와 V 함수 또한 동기화가 보장 되어야 한다.
- 카운팅 세마포마 (S 가 1 초과) 와 이진 세마포어 (S 가 1) 이 존재한다. 이진 세마포어는 뮤텍스 락과 거의 동일하다.
    - 카운팅 세마포어 :  DB Connection 개수 제한이나 파일 다운로드 동시 실행 제한 등 자원의 최대치를 한정해서 운용하는 방식.

**뮤텍스 vs 세마포어** 

- 뮤텍스 : 주로 상호 배제를 위해 사용되며, 하나의 자원에 하나의 스레드만 접근하도록 보장해야 하는 경우에 사용된다.
- 세마포어 : 주로 리소스의 한정적인 사용을 제어하는 데 사용되며, 특정 개수의 스레드만이 동시에 자원에 접근하도록 제한하고자 할 때 사용된다. (= 대기열)

**모니터**

- 자바가 동기화를 지원하기 위해 사용하는 메커니즘은 모니터이며, 뮤텍스나 세마포어 보다 더 고수준의 동기화 기법이다.
- 모든 자바 객체는 기본적으로 모니터를 가지며, 여러 스레드가 임계영역에 진입하려고 할 때 JVM 은 모니터를 사용하서 스레드간 동기화를 제공한다.
