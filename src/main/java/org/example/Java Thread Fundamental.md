### 스레드 종류

**하드웨어 스레드**

병렬적으로 몇개의 소프트웨어 스레드를 수행할 수 있을지를 결정.

- 8core CPU 가 코어당 스레드를 2개 제공한다면, 총 16개의 하드웨어 스레드
- 즉 코어 하나당 2개의 동시 작업을 수행하여 총 16개의 동시 작업이 가능한 CPU 를 의미
- OS 관점에서 보면, 가상의 코어라고 볼 수 있다. (실제 1코어인데, 1코어가 2개의 스레드를 가지고 있다면 OS 입장에서는 2코어로 인식)

**OS 스레드**

CPU 에서 실제로 실행되는 단위, CPU 스케줄링의 단위

- OS 스레드의 컨텍스트 스위칭은 커널이 개입 (컨텍스트 스위칭이 일어날 때 마다 UserMode → KernelMode 전환)
- 사용자 코드와 커널 코드 모두 OS 스레드에서 실행됨

Q. OS 스레드 8 개가, 하이퍼 스레딩이 적용된 인텔 듀얼코어 위에서 동작한다면 OS 스레드들을 어떻게 코어에 균등하게 할당할 수 있을까?

- 듀얼코어 : 실제 코어 개수 2개
- 하이퍼 스레딩 :  core 개수 x 2  = OS 관점에서의 core 는 4개
- 8개의 OS 스레드는  OS 관점의 스레드 4개에 각각 2개씩 분배가능.

**User Thread**

스레드의 개념을 프로그래밍 레벨에서 추상화 한 것

- 유저 스레드가 CPU 에서 실행되려면 OS 스레드와 반드시 연결돼야 한다.
- `Thread thread = new Thread()`  에서, start() 메소드를 실행하게 되면 **clone** 이라는 system call 이 일어난다. 이 system call 은 OS Thread 를 하나 생성하고, **이 스레드를 User level 의 스레드와 연결이 된다.**

**그럼 User Thread 와 OS Thread 는 어떻게 연결 시킬까?**

1. One-to-One model (오늘날의 JAVA 스레드)
    - 스레드 관리를 OS 에 위임한다.
    - 스케줄링도 커널이 수행한다.
    - 1:1 매핑이기 때문에 하나의 스레드가 block 되어도 다른 스레드는 잘 동작한다.
2. Many-to-One model
    - OS 스레드 하나와 여러 User Thread 의 구조
    - 유저 스레드간의 스위칭이 매우 빠름
    - OS 관점에서 보면 싱글 스레드 이기 때문에 race condition 이 발생하지 않는다.
    - 멀티 코어를 활용할 수 없고, User Thread 중 하나가 블락되면, 모든 스레드가 block 된다.
3. Many-to-Many model
    - 위 두가지 모델의 장점을 합침
    - 복잡한 구현
    - GO 언어가 지원하는 모델

### 스레드 실행 및 종료

- 자바 스레드는 JVM 에서 User Thread 를 생성할 때, 시스템 콜을 통해서 커널에서 생성된 커널 스레드와 1:1 매핑 되어 최종적으로 커널에서 관리된다.
- JVM 에서 스레드를 생성할 때 마다 커널에서 자바 스레드와 대응하는 커널 스레드를 생성한다.
- ~~자바 스레드는 어떻게 보면 껍데기에 불과하다..~~

<img width="679" alt="스크린샷 2024-04-28 오후 3 26 17" src="https://github.com/kihyuk-jeong/Java-Concurrency/assets/39195377/612fcc19-997d-4b50-b640-47583d8c45c7">


1. 메인 스레드가 새로운 스레드를 생성한다.
2. 메인 스레드가 start() 메서드를 호출해서 스레드 실행을 시작한다.
3. 내부적으로 네이티브 메서드인 start0() 를 호출해서, 커널에게 커널 스레드를 생성하도록 시스템 콜을 요청한다.
4. 커널 스레드가 생성되고 자바 스레드와 커널 스레드가 1:1 매핑이 이루어진다.
5. 커널 스레드는 OS 스케쥴러로부터 CPU 를 할당을 받기 까지 실행대기 상태에 있다.
6. 커널 스레드가 스케줄러에 의해 실행상태가 되면, JVM 에서 매핑 된 자바 스레드의 run() 메서드를 호출한다.

**참고로, start() 메서드가 아닌 run() 메서드를 직접 실행하면, 새로운 스레드가 생성되지 않고 호출한 스레드의 실행 스택에서 run() 메서드가 실행될 뿐이다.**

**🗝 스레드 스택**

- 스레드가 생성되면 해당 스레드를 위한 스택이 같이 만들어진다.
- 스택은 각 스레드마다 독립적으로 할당되어 작동하기 때문에 스레드 간 접근하거나 공유할 수 없고, 이는 스레드로부터 안전하다 할 수 있다.
- 스택은 OS 에 따라 크기가 주어지고 주어진 크기를 넘기게 되면 StackOverFlowError 가 발생한다.

### 스레드 생명주기

(순서는 아님)

1. NEW  : 스레드 객체는 생성 되었지만, 아직 시작 하지 않은 상태로서  JVM 에 객체는 존재 ㅏ지만 아직 커널로의 실행은 되지 않은 상태 (즉, OS 스레드와 1:1 매핑 되지 않은 상태)
    - 언제든지 실행할 준비가 되어있는 상태
    - 실행상태로 전환하기 위해서는, 현재 스레드가 어떤 상태로 존재하든지 반드시 실행 대기 상태를 거쳐야 한다.
    - 즉, 바로 실행되는 것이 아닌 Runnable 상태를 거쳐야함
2. 스케줄링 : NEW 상태의 스레드에게 실행할 시간을 제공하는 것은 OS 스케줄러의 책임이다.
    - 스케줄러는 멀티 스레드 환경에서 스레드에게 고정된 시간을 할당 ( 하나의 CPU가 계속해서 하나의 스레드 일만 할 수 없으니) 해서 실행 상태와 실행 가능한 상태를 오가도록 스케줄링 한다.
3. 실행 : 스케줄러에 의해 스케줄링 되면 CPU 를 할당 받아 run() 메서드를 호출한다.
    - 이 단계에서, 컨텍스트 스위칭이 지속적으로 발생 ( 실행 → 스케줄링 → 실행 → 스케줄링..) 한다.
    - 이 단계가 실행되면서 OS 스레드와 1:1 매핑된다.
4. 일시정지 (타임 웨이팅) : 스레드가 잠시 대기한다.
    - sleep(), wait(), join()
    - 스레드의 대기시간이 길어지고, CPU 의 할당을 계속 받지 못하는 상황이 발생하면 기아 상태가 발생하게 되는데 이 상황을 피할 수 있다.
5. 실행 대기 상태 : 일시정지 이후, 주어진 시간이 경과하면 실행 대기상태로 변경된다.
    - 또는 인터럽트가 발생하면 실행 대기 상태로 전환된다.
6. 블럭 상태 : 임계 영역에 접근한 스레드는 자신이 Lock 흭득할 때 까지 대기한다.
    - 스레드가 동기화 된 임계 영역에 접근을 시도하다가 락을 흭득하지 못해서 차단된 상태
    - 락을 흭득하면 실행 대기 상태가 된다.
7. 일시정지 : 타임 웨이팅처럼 대기하지만, 정해진 시간 없이 다른 스레드에 의해 notify() 를 받을 때 까지 대시한다.
    - A 스레드에서 B 스레드에 join() 을 걸면 B 스레드가 완료되거나 A 스레드에 대한 인터럽트가 발생할 때까지 대기한다.
        - B 스레드 인터럽트에 대해서는 직접적인 영향은 없지만, 인터럽트로 인해 B 스레드가 종료될 경우 A 스레드는 대기상태에서 벗어날 수 있다.
