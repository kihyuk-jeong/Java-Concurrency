### 스레드풀

- 스레드풀은 다수의 스레드를 미리 생성하고 관리하여 작업을 호율적으로 처리하는 디자인 패턴이다.
- 자바에서는 스레드 풀을 사용할 수 있는 Executor 프레임워크를 제공하고 있다.

**필요한 이유**

- 스레드 생성 비용 절감 : 스레드 생성 비용은 높다. 그래서 미리 스레드를 생성하고 초기화하여 대기 상태로 유지함으로써 스레드 생성 비용을 줄인다.
- 재사용 : 스레드 풀은 작업이 종료된 스레드를 대기 상태로 전환하여 재사용하기 때문에 반복적인 스레드 생성 및 삭제 오버헤드를 피한다.
- 동시성 제어 : 동시에 실행되는 스레드 개수를 제어하여 시스템 리소스의 과도한 사용을 방지한다. 또한 스레드간 경합으로 인한 성능 저하를 예방한다.
- 대량 요청 시스템 보호 : 스레드 풀에 적절한 양의 스레드만 생성해 놓음으로써 리소스가 허용한 한도에서 요청을 대기하도록 할 수 있다.

### **Runnable vs Callable**

**Runnable**

- run() 메서드를 정의하며 인수가 없다.
- Checked Exception 예외를 던질 수 없다.
- 주 용도는 스레드에서 실행할 작업을 정의하는 것이다.
- 작업이 완료되면 별도의 결과를 반환하지 않는다.

**Callable**

- call() 메서드를 정의하며, 인수가 없다.
- Checked Exception 예외를 던질 수 있다.
- 주 용도는 결과를 반환하여 결과를 기반으로 예외를 처리해야 하는 경우이다.
- 작업이 완료되면 Future 를 반환한다.

### ExecutorService API - 다중 작업 처리

- ExecutorService 는 여러 작업을 실행하고 결과를 수집하는 데 사용되는 메서드를 제공한다.

**invokeAll method**

1. `List<Future> invokeAll(Collection tasks)` 
    - 여러 개의 Callable 작업을 동시에 실행하고, 모든 작업이 완료될 때까지 블록되며 각 작업의 결과를 나타내는 Future 객체의 리스트를 반환한다.
    - 작업이 완료되면 Future.isDone() 이 ture 가 되며, 작업은 정상적으로 종료되거나 예외를 던져 종료될 수 있다.
    - 대기 중에 인터럽트가 발생한 경우, 아직 완료되지 않은 작업들은 취소된다.
2. `List<Future> invokeAll(Collection tasks, long timeout, TimeUnit unit)` 
    - 기본적으로 1번 메소드와 동일하지만, timeout 시간 만큼만 처리한다.
    - 타임아웃이 발생한 경우 이 작업 중 일부는 완료되지 않을 수 있으며 완료되지 않은 작업은 취소된다.

→ invokeAll() 은 여러 작업들 중 시간이 가장 오래 걸리는 작업의 시간 만큼 소요된다.

### ThreadPoolExecutor

- ThreadPoolExecutor 는 corePoolSize 및 maximumPoolSize ㄹ 설정된 개수에 따라 풀 크기를 자동으로 조정한다.
- ThreadPoolExecutor 는 새 작업이 제출 될 때 corePoolSize 미만의 스레드가 실행 중이면 corePoolSize 가 될 때까지 새 스레드를 생성한다.
- 여기서 중요한 것은, corePoolSize 를 초과하는 작업이 대기중이라고 바로 maximumPoolSize 만큼 스레드를 추가하는 것이 아니다.
- Queue 에 task 를 대기시켜놓고, Queue 에 대기중인 task 가 가득 차 있는 경우에만 maximumPoolSize 만큼 스레드풀에 스레드를 생성한다.
- **참고로 시작부터 corePoolSize 만큼 스레드를 생성하지 않는다.**
    - 불필요한 자원 낭비를 방지하기 위해 스레드 풀 내 스레드 개수는 1개로 시작하고, task 가 추가로 들어왔을 때 corePoolSize 만큼 스레드가 신규로 생성된다.

**keepAlive**

- keepAlive 설정에 따라 idle 상태의 스레드는 제거된다. (corePoolSize 만큼만 남아있음. 단, allowCoreThreadTimeout 메서드를 통해 core 스레드에도 적용할 수 있다.)

**BlockingQueue**

- SynchronousQueue
    - **`newCachedThreadPool()`** 에서 사용한다.
    - 내부적으로 크기가 0인 큐로서, 작업을 대기열에 넣으려고할 때, 실행할 스레드가 즉시 없으면 새로운 스레드가 생성된다.
    - 해당 큐는 펴균적인 처리보다 더 빨리 작업이 요청되면 스레드가 무한정 증가할 수 있다.
- LinkedBlockingQueue
    - `Executors.newFixedThreadPool()` 에서 사용한다.
    - 무제한 크기의 큐로서, 코어사이즈의 스레드가 모두 사용 중인 경우 새로운 작업이 제출되면 대기열에 등록하고 대기하게 된다.
    - 즉, 해당 큐를 사용한다면 maximumPoolSize 를 설정해도 아무런 효과가 없다.
    - 일시적인 요청의 폭증을 완화하는 데 유용할 수 있지만, 평균적인 처리보다 더 빨리 작업이 도착할 경우 큐에 무한정 작업이 쌓일 수 있다.
- ArrayBlokcingQueue
    - 내부적으로 고정된 크기의 배열을 사용하여 작업을 추가하고 큐를 생성할 때 최대 크기를 지정해야 하며 한 번 지정된 큐의 크기는 변경할 수 없다.
    - 큰 대기열(큐) 와 작은 풀 사용 시 CPU 사용량 및 컨텍스트 스위칭 오버헤드는 감소하지만, 처리량 감소
    - 작은 대기열과 큰 풀 사용 시 CPU 사용률이 높아지지만 대기열이 가득 찰 경우 추가적인 작업을 거부하기 때문에 처리량이 감소할 수 있다.

**스레드, CPU 와 Memory 상관관계**

- 많은 스레드를 사용하면 메모리 자원에 큰 영향을 미치게 된다.
    - 각 스레드는 자체 스택을 가지고 있으며, 일반적으로 몇 백 KB ~ MB 사이의 메모리를 소비한다.
    - 따라서 스레드의 수가 많아질수록 전체 메모리의 샤용량이 증가한다.
- CPU 는 실행 중인 스레드의 작업 유형과 복잡성에 따라 다르다.
