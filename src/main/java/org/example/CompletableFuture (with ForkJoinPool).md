### 동기 / 비동기 / 블로킹/ 넌블로킹 기초 지식

**비동기**

- 비동기는 작업이 순차적으로 실행되지 않고, 각 작업이 다른 작업의 완료를 기다리지 않고 독립적으로 실행되는 방식을 의미한다.
- 한 작업이 시작된 후에도 다음 작업이 바로 시작될 수 있으며 작업의 결과에 관심이 없고 기다리지 않으며 다른 작업을 실행할 수 있다.
- 비동기 작업은 주로 I/O 작업과 같이 시간이 오래 걸리는 작업을 다룰 때 유용하며, 다수의 작업을 동시에 처리하거나 빠른 응답시간을 보장해야 하는 경우에 활용된다.

**동기 + 비동기**

작업을 처리하는 작업자가 두 명인 비동기 상황에서도 동기식 처리가 가능하다.

- 작업자 1은 작업자 2의 작업이 마쳤는지 계속 확인한다. 즉, 결과에 관심 있다.
- 작업자 1은 작업자2의 작업이 마쳤는지 확인하는 동안 대기 할 수도 있다.

→ 즉, 한 작업자가 다른 작업자의 작업 결과에 관심이 있고 확인할 경우 비동기 안에서 동기식 처리가 될 수 있다.

**블로킹**

- 블로킹은 동기 작업에서 나타나는 현상으로, 작업이 완료될 때까지 실행 흐름을 멈추고 대기하는 상태를 의미한다.
- 파일을 읽거나 네트워크에서 데이터를 받아오는 I/O 작업은 대부분 블로킹 작업에 해당하며, 이 작업이 완료될 때까지 다른 작업은 차단되고 대기 상태에 놓이게 된다.
- 블로킹 작업은 주로 작업이 완료될 때까지 결과를 기다려야 하는 경우에 사용되며 대부분 동기적인 처리에서 나타난다.

**블로킹 + 비동기**

- 작업자 1은 작업자 2의 작업이 마쳤는지 계속 확인한다. 즉, 작업자1은 작업자 2의 작업이 완료될 때 까지 블로킹 (아무 일도 하지 않음) 된다.

**넌블로킹**

- 넌블로킹은 비동기 작업에서 나타나는 현상으로, 실행 흐름이 지속되는 특성을 지닌다.
- 특정 작업이 진행 중일 때에도 다른 작업이 계속 실행되며, 작업이 완료되지 않았더라도 대기하지 않고 다음 작업을 처리하는 방식을 의미한다.

**넌블로킹 + 비동기**

- 작업자 1은 작업자 2의 작업이 완료되지 않아도 계속해서 다른 일을 한다.
- 다른 일을 하다가 작업자 2가 callback 을 통해 완료되었다고 알리면 그제서야 작업자 2의 결과와 함께 다른 결과를 만든다.

---

### 개요

CompletableFuture 는 비동기 프로그래밍을 쉽게 다루고 복잡한 비동기 작업을 효과적으로 처리할 수 있도록 해주는 도구로 Java 8 에 도입 되었다.

---

### ForkJoinPool

작업을 작은 조각으로 나누고 병렬로 처리하여 다중 코어 프로세서에서 효율적으르 작업을 수행할 수 있도록 도와준다.

- 병렬처리 : 스레드 풀은 시스템의 프로세서 코어수에 따라 스레드를 생성하고, 작업은 분할되어 여러 스레드에서 병렬로 실행된다.
- 분할-정복 알고리즘 : 복잡하고 큰 문제를 작은 하위 문제로 분할하고 각 하위 문제를 병렬로 처리한 다음 다시 병합하여 처리할 수 있다.
- Work-Stealing 알고리즘 : 작업이 끝난 스레드가 다른 스레드의 대기 중인 작업을 스틸하여 실행함으로 스레드 간 작업의 균형과 효율적인 병럴 처리가 가능하다.

**Work-Stealing**

- 글로벌 큐 라는 개념이 존재하고 이 큐 내부에는 Task 가 존재한다.
- 각 스레드는 글로벌 큐에서 task 를 가져가고, 자기 자신만의 (스레드) 큐의 head 부분에 글로벌 큐에서 가져온 task 를 담아서 작업을 처리한다. 이 때 작업이 완료되면 head 에 존재하는 task 를 pop 한다.
- 만약 다른 스레드에서 워크 스틸이 일어날 경우 특정 스레드 큐의 tail 부분에서 작업을 스틸해 가기 때문에 동기화 없이 (Lock-Free) 사용이 가능하다. (즉, 스레드 세이프 하다)
- 다만 스레드 개수가 상당히 많아지면 work-strealing 하려는 스레드 간 경합이 심해질 수 있다.

**ForkJoinPool 생성**

- 기본적으로 어플리케이션에서 공용으로 사용하는 스레드는 CPU 코어 개수 - 1 개 만큼 생성된다.
    - `Runtime.getRuntime().availableProcessors()-1`
- ForkJoinPool.commonPool() 은 전체 어플리케이션에서 스레드를 공용으로 사용하기 때문에 다음과 같은 주의가 필요하다.
    1. 스레드 블로킹 :
        1.  I/O Bound 작업은 스레드를 블록시키는 작업으로, commonPool() 에서 실행 시 스레드 부족으로 다른 작업이 지연 될 수 있다.
        2. 별도의 스레드 풀을 생성하여 I/O 작업과 CPU 작업을 분리하고 I/O 작업을 별도의 스레드에서 처리하는 것을 고려해야 한다.
    2. 기아 상태
        1. I/O 작업이 지속적으로 블록되면 CPU 작업이 실행 기회를 얻지 못하고 기아 상태에 빠질 수 있다.
        2. 스레드 풀을 분리하여 CPU 작업이 충분한 실행 기회를 얻도록 관리해야 하고 대신 스레드가 필요 이상으로 생성되어 리소스 비용이 커지지 않도록 해야한다.
    

**ForkJoinPool 대신 ThreadPoolExecutor** 

CompletableFuture 사용 시 기본적으로 ForkJoinPool 을 사용하는데, 별도의 옵션을 통해 ForkJoinPool 이 아닌 ThreadPoolExecutor 를 통해 생성된 스레드 사용이 가능하다.

다음과 같은 방식도 가능하다.

- I/O 바운드 작업은 ThreadPoolExecutor 스레드 풀의 스레드로 실행
- CPU 바운드 작업은 ForkJoinPool 의 스레드로 실행
<img width="259" alt="스크린샷 2024-05-09 오후 11 35 42" src="https://github.com/kihyuk-jeong/Java-Concurrency/assets/39195377/01ba7d66-c6eb-41b3-8129-bc382495f537">



**CompletableFuture 의 워커 스레드는 총 3개의 풀에서 가능하다.**

- CPU 코어 갯수 만큼 생성되는 commonPool))
- 사용자가 직접 별도로 생성한 Custom ForkJoinPool()
- ThreadPoolExecutor 로 생성한 ThreadPool (not forkJoinPool)

---

**CompletableFuture 는 총 3가지 종류의 스레드 풀로 동작시킬 수 있음**

1. CPU 코어 만큼 생성되는 commonPool()
    1. 만약 CPU 코어가 10 이라면 (10-1) 해서 총 9개의 스레드가 생성됨.
    2. 이 스레드는 application 전역에서 함께 사용하기 때문에 I/O Bound 작업 ( 외부 API call, DB 조회 등등) 에는 적합하지 않음.
2. 직접 생성한 ForkJoinPool  (ForkJoinPool pool = new ForkJoinPool(4))
    1. CPU 코어만큼 생성되는 commonPool() 과 전혀 무관한 스레드 풀
    2. ForkJoinPool 의 특징 (work-stealing 등) 이 필요할 경우 사용
3. ThreadPoolExecutor 로 생성한 스레드 풀 (forkJoinPool 아님)
    1. I/O bound 작업에 적합함.

CompletableFuture 사용할 때 해당 작업이 CPU Bounded 작업 (연산) 인지, I/O Bounded 작업 인지에 따라 어떤 종류의 스레드를 사용할 것인지 설정할 수 있음.
