## ⚙️ 운영체제 기초

### Process

- 운영체제에 의해 파일 시스템에 설치되어 있는 파일을 **프로그램** 이라 칭한다.
(실행되지 않은 상태로, 아직은 프로세스가 아니다.)
- 프로세스는 프로그램의 실제 실행을 의미하며 프로그램 파일을 실행함으로써 프로그램 데이터들이 메모리에 올라와 **CPU를 할당받고 명령을 수행할 수 있는 상태다**
- 프로세스는 운영체제로부터 자원을 할당받은 최소 작업 단위이다.
- 프로세스가 메모리를 할당받으면 그중 일부는 운영체제의 커널이 사용한다.
- 운영체제는 프로세스마다 각각 독립된 메모리 영역 (code/data/statc/heap) 을 할당해 준다.
- 프로세스는 총 4개의 영역으로 나눌 수 있다.
    - stack : 함수 안에서 선언된 지역변수, 매개변수, 리턴값 등이 저장되며 함수의 호출과 함께 할당되며 함수의 호출이 완료되면 소멸되는 영역
    - heap : 사용자에 의해 메모리 공간이 동적으로 할당되고 해제되며, 배열이나 객체, 문자열 등이 저장됨
    
    `→ 스택과 힙 모두 동적으로 할당된다.`
    
    - data : 코드가 실행되면서 사용하는 전역변수 (static 변수) 고 프로그램의 시작과 함께 할당되며 종료 시 소멸된다.
    - code : 사용자가 작성한 프로그램 함수들의 코드로 CPU 는 코드영역에 저장된 명령어를 하나씩 가져가서 처리한다.
<img width="679" alt="스크린샷 2024-04-28 오후 3 22 53" src="https://github.com/kihyuk-jeong/Java-Concurrency/assets/39195377/6ba81f06-8f85-4a26-ac24-701410cda6af">

- 서버가 시작될 때, 초 세트의 자식 프로세스가 생성되고 클라이언트로부터 요청이 오면 서버는 대기중이 자식 프로세스 중 하나를 선택하여 이 요청을 처리하도록 한다.
- 선택된 자식 프로세스는 요청을 처리하고, 클라이언트에게 필요한 리소스를 전송한다.
- 요청 처리가 완료되면 자식 프로세스는 종료되거나 다음 요청을 처리하기 위해 재사용 된다.

→ 하지만, 실제로 현대 웹 서버는 성능과 자원 사용 최적화를 위해 자식 프로세스 대신 스레드를 사용하거나 이벤트 기반의 비동기 처리 모델을 채태하는 경우도 많다.

### Thread

프로세스는 운영체제로부터 메모리 자원을 할당 받고 할당받은 메모리에 올라온 데이터들을 CPU 를 할당받아 명령을 실행하는 자원은 스레드

- 프로세스는 반드시 하나 이상의 스레드를 가진다.
- 자바에서 main() 를 실행시키면 JVM 이 실행되고, 이 JVM 도 프로세스다. 이 시점에 JVM 은 main thread 를 생성한다.

<img width="712" alt="스크린샷 2024-04-28 오후 3 23 15" src="https://github.com/kihyuk-jeong/Java-Concurrency/assets/39195377/599bbe6b-157f-40bd-9af1-fe68b9390e33">


- 참고로 CPU 는 동시에 2개 이상의 스레드를 실행할 수 없으며, 빠른 전환으로 인해 동시에 실행하는 것 처럼 보일 뿐
- 어떤 스레드를 먼저 선점 할지는 CPU 의 스케줄러 알고리즘에 따라 결정된다.

요약

- 프로세스는 운영체제로부터 자원을 메모리에 할당받아 실행된 최소 작업 단위
- 스레드는 운영체제 스케줄러에 의해 관리되는 CPU 의 최소 실행 단위

## 👯 Parallel & Concurrent

병렬성과 동시성은 비슷하지만 완전히 다른 개념이다.

- Parallel (병렬성)
    - 멀티 코어 프로세서에서 동시에 실행되는 동일한 작업
    - 예를들어 A 라는 사람은 A1 이라는 작업을 하고, B 라는 사람은 A2 라는 작업을 동시에 수행한다.
    - 병렬성은 작업해야 할 수가 CPU 코어수 보다 같거나 적을 경우 효율성이 좋다.
    - 병렬성은 반드시 하드웨어가 뒷받침 되어야 한다. (CPU 단일 코어로는 병렬성을 구현할 수 없다.)
    - 즉 CPU 가 놀지 않고 최대한 바쁘게 동작해야 한다.
        
        <img width="627" alt="스크린샷 2024-04-28 오후 3 23 28" src="https://github.com/kihyuk-jeong/Java-Concurrency/assets/39195377/85d5aec6-19b3-4bb5-af8c-2dd39e1f59ff">

        
    
- Concurrent (동시성)
    - 특정한 순서 없이 겹치는 기간에 시작하며 실행 및 완료 되는 여러 작업에 관한 것을 의미한다.
    - 예를 들어 A 라는 사람이 A1 이라는 작업과 A2 라는 작업을 함께 수행 
    (A1 이라는 작업을 하다가 A2 라는 작업을 하고, 다시 A1 을 하고..)
    - 동시성의 목적은 CPU 가 한 번에 많은 일을 처리하는 것에 중점을 둔다. 즉, 많은 작업들을 아주 빠른 시간으로 교체하면서 전체 작업을 처리한다.
    - 동시성은 작업해야 할 수가 CPU 코어수 보다 많을 경우 해당되며, 동시성이 없으면 작업을 순차적으로 진행해야 한다.
        
        <img width="616" alt="스크린샷 2024-04-28 오후 3 23 40" src="https://github.com/kihyuk-jeong/Java-Concurrency/assets/39195377/d8b40b96-9aca-4b57-8cae-5680e5f4becc">


**병렬성 vs 동시성 실생활 예시**

**병렬성** 

- 병렬성은 여러 작업이 동시에 실행되는 것을 의미한다.
- 4명의 요리사가 한 주방에서 각기 다른 요리를 동시에 만드는 상황. 각 요리사는 서로 다은 작업을 동시에 수행하고 있다.

**동시성**

- 동시성은 여러 작업이 동시에 실행되는 것처럼 보이지만, 실제로는 작업들이 번갈아 가며 진행되는 것을 말한다.
- 1명의 요리사가 여러 요리를 만들어야 하는 상황에서, 요리사는 첫번째 요리를 조금 만들고, 두번째 요리를 만들고, 다시 첫 번째 요리를 만들고.. 와 같은 과정을 반복한다. 여기서 요리사는 동시에 음식을 만들고 있는 것 처럼 보이지만, 실제로는 번갈아 가면서 요리를 만드는 것읻.

**즉, 병렬성은 실제로 여러 작업이 동시에 실행되는 것이고, 동시성은 시간을 나누어 여러 작업을 번갈아 가면서 수행하는 것이다.**

**병렬성은 물리적으로 동시에 여러 프로세스를 처리할 수 있는 시스템에 효과적이고, 동시성은 한정된 자원을 효율적으로 사용하려 할 때 유용하다.**

### 동시성

```java
    		int cpuCores = 13;

        // CPU 개수를 초과하는 데이터를 생성
        List<Integer> data = new ArrayList<>();
        for (int i = 0; i < cpuCores; i++) {
            data.add(i);
        }

        // CPU 개수를 초과하는 데이터를 병렬로 처리
        long startTime2 = System.currentTimeMillis();
        long sum2 = data.parallelStream()
                .mapToLong(i -> {
                    try {
                        Thread.sleep(500);
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                    return i * i;
                })
                .sum();
```

- `parallelStream`사용 시 작업의 수가 CPU 코어 수 보다 많다면 작업 수와 코어 수 차이 만큼 일부 Thread 는 CPU 를 할당받기 까지 기다리는 시간이 발생한다.
- 예를 들어 CPU 의 코어가 12개인 서버에서 총 13개의 작업을 `parallelStream` 으로 처리한다면, 1개의 작업은 CPU 를 할당받지 못해 대기 상태에 들어가게 된다.
→ 하나의 CPU 는 동시에 2개의 Thread 를 할당받아서 처리할 수 없다.

### 병렬성과 동시성 조합

ThreadPoolExecutor : 병렬성으로 처리 성능을 극대화 하고 동시성으로 CPU 자원을 효율적으로 운용한다.

<img width="680" alt="스크린샷 2024-04-28 오후 3 23 55" src="https://github.com/kihyuk-jeong/Java-Concurrency/assets/39195377/62b9682b-6174-48e8-9b7a-2a39c1ba304c">


ForkJoinPool : 하나의 Task 를 Sub Task 로 분할하여 병렬처리함으로써 전체 작업 성능을 높인다.

<img width="677" alt="스크린샷 2024-04-28 오후 3 24 04" src="https://github.com/kihyuk-jeong/Java-Concurrency/assets/39195377/f534ede6-7e78-477c-ada9-791bf1d88d35">


### Context Switch

**발생 조건**

- 실행중인 프로세스에서 I/O 호출이 일어나 해당 I/O 작업이 끝날때 까지 프로세스가 running 에서 waiting 상태로 전이된 경우
- Round Robin 스케쥴링 등 운영체제의 CPU 스케줄러 알고리즘에 의해 현재 실행중인 프로세스가 사용할 수 있는 시간 자원을 모두 사용했을 때, 해당 프로세스의 작업을 중지 하고 다른 프로세스를 실행시켜주는 경우

**프로세스의 컨텍스트 스위칭의**

1. CPU 가 프로세스 1 선점
2. 프로세스 1에게 할당된 타임슬라이스 경과 또는 I/O 작업 
3. CPU 가 프로세스 1의 정보를 PCB 에 저장

←—————컨텍스트 스위칭 과정 진행——————>

1. CPU 가 프로세스 2 작업 실행

→ 위와 같이 컨텍스트 스위칭이 발생하는 경우 그 시간동안 CPU 는 일을 하지 않는다. 

**스레드의 컨텍스트 스위칭**

전체적인 과정은 프로세스의 컨텍스트 스위칭과 동일하지만, PCB 대신 PCB 내부에 존재하는 TCB 에 현 스레드의 정보를 저장한다는 차이점이 있다.

<img width="665" alt="스크린샷 2024-04-28 오후 3 24 17" src="https://github.com/kihyuk-jeong/Java-Concurrency/assets/39195377/61edf1e9-51ac-48cb-87e2-ec6342073d98">


**프로세스 컨텍스트 스위칭 vs 스레드 컨텍스트 스위칭**

- 프로세스는 컨텍스트 스위칭 시 메모리 주소 관련 여러가지 처리 (CPU 캐시 초기화, TLB 초기화, MMU 주소 체계 수정 등) 가 필요하기 때문에 오버헤드가 크다.
- 스레드는 프로세스 내 메모리를 공유하기 때문에 메모리 주소 관련 처리를 할 필요가 없다.
- but, 스레드는 생성하는 비용이 커서 많은 수의 스레드 생성은 메모리 부족 현상이 발생할 수 있으며, 빈번한 컨텍스트 스위칭으로 application 자체에 성능 저하로 이어질 수 있다.

### CPU bound & I/O bound

프로세스는 기본적으로 CPU 작업과 I/O 작업의 연속된 흐름으로 진행된다.

- 프로세스는 CPU 명령어를 수행하다가 I/O 작업을 만나면, 해당 작업을 대기 상태로 변경하고 CPU 가 다른 작업을 처리하러 간다. 이후 I/O 작업이 완료되면 다시 기존 CPU 작업을 수행한다.
- 특정 태스크가 완료될 때까지 이를 계속 반복한다.
- 프로세스마다 CPU Burst 와 I/O Burst 가 차지하는 비율이 균일하지 않다.

**아래 비율을 기준으로 해서 어떤 프로세스가 CPU bound 인지 I/O bound 인지 판단할 수 있다.**

☁︎ **CPU Bounded Process**

- CPU 버스트 작업이 많은 프로세스로, I/O 버스트 가 거의 없는 경우에 해당한다.
- 머신러닝, 블록체인, 동영상 편집 프로그램 등 CPU 연산 위주의 작업을 하는 경우를 의미한다.
- 멀티 코어의 병렬성을 최대한 활용해서 스레드를 운용해야 하며, 일반적으로 CPU 코어수와 스레드 수를 맞춘다.

<img width="701" alt="스크린샷 2024-04-28 오후 3 24 29" src="https://github.com/kihyuk-jeong/Java-Concurrency/assets/39195377/d01f3631-4ab2-4014-acda-8a007c722279">


☁︎ **I/O Bounded Process**

- I/O Burst 가 빈번히 일어나는 프로세스로, CPU 작업이 매우 짧다.
- 파일 입출력, 키보드, DB, 네트워크 외부 연결이나 입출력 장치와의 통신 작업이 많은 경우 해당한다.
- CPU 코어가 많을 경우 멀티 스레드의 동시성을 최대한 활용하여 CPU 가 Idle 상태가 되지 않도록 해야 한다.
→ 스레드가 적을 경우 I/O 작업이 일어날 때 CPU 가 Idle 상태로 남아있을 확률이 높다. 따라서 I/O 작업이 진행중인 스레드가 존재할 때 곧바로 다른 스레드의 작업을 CPU 가 할당받아서 처리할 수 있도록 스레드를 운용해야 한다.  (동시성을 최대한 보장. CPU 가 Thread 1 을 처리 하다가, Thread 2를 처리)

### 사용자 모드 & 커널 모드

운영체제의 여러 기능 중 핵심 기능을 담당하는 부분을 커널 이라고 한다.

<img width="685" alt="스크린샷 2024-04-28 오후 3 24 41" src="https://github.com/kihyuk-jeong/Java-Concurrency/assets/39195377/684e7675-3a74-4852-b433-2b47d9a6b0ba">


**운영체제는 응용 프로그램이 하드웨어 자원에 직접 접근하는 것을 방지하여 자원을 보호한다.**

- 응용프로그램이 하드웨어 자원에 직접 접근해서 조작할 수 있다면, 자원의 관리가 되지 않고 프로세스 간 데이터가 훼손될 수 있다.
- 응용프로그램이 하드웨어 자원에 접근하려고 할 때는 반드시 운영체제를 통해서만 접근하도록 한다.

**CPU 권한 모드**

CPU는 명령어를 실행할 때 크게 두 가지 권한 모드로 구분해서 실행한다. CPU 는 동작하는 동안 두가지 모드를 번갈아 가면서 수행한다.

- 사용자 모드 (Mode bit = 1)
    - 사용자 응용프로그램의 코드가 실행되는 모드로, 메모리의 유저 영역만 접근 가능
    - disk, memory, printer 등 여러 I/O 장치들과 같은 특정 리소스는 접근 불가능
    - 파일 읽기/쓰기 시 I/O 작업은 커널모드에서 수행하고, 해당 결과를 리턴받아 사용자모드에서 작업을 수행한다.
    - 대부분의 응용프로그램들은 입출력 장치나 파일로의 접근이 필요하기 때문에 유저모드 만으로는 프로세스를 정상적으로 실행시킬 수 없다.
- 커널 모드 (Mode bit = 0)
    - 커털 영역의 코드가 실행되는 모드로, 메모리의 유저영역과 커널영역 모두 접근 가능
    - 하드웨어 자원에 직접 접근할 수 있음.
    

🛎 **시스템 호출 (System Call)**

- 응용프로그램이 운영체제의 커널이 제공하는 서비스를 이용할 수 있도록 커널모드에 접근하기 위한 인터페이스
- 응용 프로그램이 파일 입출력이나, 화면의 메시지 출력 등 I/O 작업이 필요할 때 커널 모드로 전환 된 상태로 CPU 가 실행되어야 하기 때문에 반드시 시스템 콜을 사용해야 한다.

<img width="675" alt="스크린샷 2024-04-28 오후 3 24 53" src="https://github.com/kihyuk-jeong/Java-Concurrency/assets/39195377/100bc311-5a97-4624-8365-a2be71396d30">


- 사용자 응용프로그램 작업 과정에서 커널의 기능을 사용하기 위해 매우 빈번하게 시스템 콜을 요청하고, 이로 인해 사용자 모드와 커널 모드를 상호 전환할 수 있다.
- 사용자 모드와 커널 모드를 번갈아 오는 것은 컨텍스트 스위칭과 관련이 있다.
    - I/O 처리를 위해 반드시 시스템 콜을 통해 커널 모드로 전환해야 하는데, I/O 작업 자체가 컨텍스트 스위칭을 발생시키기 때문이다.
    - 멀테 스레드 환경에서 참고해야 할 중요한 배경적 지식이다.
    - 그러나 모든 시스템 호출이 컨텍스트 스위칭을 발생시키는 것은 아니다
